;;; RFC5322-compliant email parsing.
;;;
;;; For clarity, the name of each parser in this package is lifted directly from
;;; the spec and the layout of the parsers generally follows the ABNF, except
;;; where doing so literally would be inefficient. Specifically, some of the
;;; low-level character checks have been fused into smarter `take-while' calls.
;;;
;;; See also the following relevant sections in various RFCs.
;;;
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.6.4
;;; - https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
;;; - https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1
;;;
;;; A note on obsolete syntax. From RFC 5322:
;;;
;;; > Section 4 of this document specifies an "obsolete" syntax. There are
;;; > references in section 3 to these obsolete syntactic elements. The rules of
;;; > the obsolete syntax are elements that have appeared in earlier versions of
;;; > this specification or have previously been widely used in Internet
;;; > messages. As such, these elements MUST be interpreted by parsers of
;;; > messages in order to be conformant to this specification. However, since
;;; > items in this syntax have been determined to be non-interoperable or to
;;; > cause significant problems for recipients of messages, they MUST NOT be
;;; > generated by creators of conformant messages.
;;;
;;; parcom/email supports parsing this obsolete syntax.

(defpackage parcom/email
  (:use :cl)
  (:shadow #:atom)
  (:import-from :parcom #:<* #:*> #:<$ #:fn #:-> #:always #:maybe)
  (:local-nicknames (#:p #:parcom))
  ;; --- Exposed Parsers --- ;;
  (:export #:addr-spec #:msg-id)
  ;; --- Types --- ;;
  (:export #:address #:address-name #:address-domain)
  ;; --- Other --- ;;
  (:export #:parse #:valid-email-address? #:pretty))

(in-package :parcom/email)

;; --- Helpers --- ;;

(fn ws? (-> character boolean))
(defun ws? (c)
  (or (char= c #\space)
      (char= c #\tab)))

(fn crlf? (-> character boolean))
(defun crlf? (c)
  (or (char= c #\newline)
      (char= c #\return)))

(fn atext? (-> character boolean))
(defun atext? (c)
  "Printable US-ASCII characters not including specials."
  (or (p:ascii-letter? c)
      (p:digit? c)
      (char<= #\# c #\')
      (char<= #\* c #\+)
      (char<= #\^ c #\`)
      (char<= #\{ c #\~)
      (char= c #\!)
      (char= c #\-)
      (char= c #\/)
      (char= c #\=)
      (char= c #\?)))

(fn dtext? (-> character boolean))
(defun dtext? (c)
  (or (char<= #\! c #\Z)
      (char<= #\^ c #\~)
      (obs-no-ws-ctl? c)))

(fn obs-no-ws-ctl? (-> character boolean))
(defun obs-no-ws-ctl? (c)
  (or (char<= #\Soh c #\backspace)
      (char<= #\Vt c #\Page)
      (char<= #\So c #\Us)
      (char= #\Rubout c)))

(fn quoted-pair? (-> character character boolean))
(defun quoted-pair? (a b)
  (and (char= a #\\)
       (or (char<= #\! b #\~)
           (ws? b)
           (char= b #\nul)
           (obs-no-ws-ctl? b)
           (crlf? b))))

#+nil
(quoted-pair? #\\ #\newline)

(fn qtext? (-> character boolean))
(defun qtext? (c)
  (or (char= #\! c)
      (char<= #\# c #\[)
      (char<= #\] c #\~)
      (obs-no-ws-ctl? c)))

(fn ctext? (-> character boolean))
(defun ctext? (c)
  (or (char<= #\! c #\')
      (char<= #\* c #\[)
      (char<= #\] c #\~)
      (obs-no-ws-ctl? c)))

;; --- Static Parsers --- ;;

(defparameter +@+             (p:char #\@))
(defparameter +bracket-open+  (p:char #\[))
(defparameter +bracket-close+ (p:char #\]))
(defparameter +period+        (p:char #\.))
(defparameter +paren-open+    (p:char #\())
(defparameter +paren-close+   (p:char #\)))
(defparameter +quote+         (p:char #\"))
(defparameter +any-crlf+      (p:any-if #'crlf?))
(defparameter +consume-ws+    (p:consume #'ws?))
(defparameter +consume-atext+ (p:consume1 #'atext?))
(defparameter +skipws1+       (p:consume1 #'ws?))
(defparameter +peek-@+        (p:peek (p:alt +@+ #'p:eof)))
(defparameter +peek-eof+      (p:peek #'p:eof))

;; --- Types --- ;;

(defstruct address
  "A valid email address. Must be obtained through the parsing process and cannot
be directly constructed by the user."
  (name   nil :type string)
  (domain nil :type string))

(defun pretty (addr &optional (stream nil))
  "Pretty-print an `address'. Not at all guaranteed to be an isomorphism
with the original string from which the address was parsed, as the original may
have contained any number of junk characters or comments."
  (format stream "~a@~a" (address-name addr) (address-domain addr)))

#+nil
(pretty (p:parse #'msg-id "colin@fosskers.ca"))

;; --- Entry --- ;;

(fn parse (-> p::char-string address))
(defun parse (input)
  "Attempt to parse an email address."
  (p:parse (<* #'addr-spec #'p:eof) input))

(fn valid-email-address? (-> string boolean))
(defun valid-email-address? (s)
  (let ((s (etypecase s
             ((simple-array character (*)) s)
             (string (coerce s '(simple-array character (*)))))))
    (multiple-value-bind (res next) (funcall (<* #'addr-spec #'p:eof) (p:in s))
      (declare (ignore next))
      (p:ok? res))))

#+nil
(valid-email-address? "alice@bob.com")
#+nil
(valid-email-address? "alice")

;; --- Whitespace and Comments --- ;;

(defparameter +consume-ws-crlf+ (p:opt (*> +consume-ws+ +any-crlf+)))

(defparameter +fws+ (p:alt (*> +consume-ws-crlf+ +skipws1+) #'obs-fws))

(defun fws (offset)
  "Parser: Folding white space."
  (funcall +fws+ offset))

#+nil
(p:parse #'fws "   ")

(defparameter +opt-fws+ (p:opt #'fws))

(defparameter +obs-fws+
  (*> +skipws1+
      (p:many (*> +any-crlf+ +skipws1+))))

(defun obs-fws (offset)
  (funcall +obs-fws+ offset))

#+nil
(p:parse #'obs-fws "   ")

(defparameter +many-comments+
  (p:many1 (*> +opt-fws+ #'comment)))

;; NOTE: From the spec.
;;
;; > Runs of FWS, comment, or CFWS that occur between lexical tokens in a
;; > structured header field are semantically interpreted as a single space
;; > character.))
;;
;; I interpret this to mean that comments and run of spaces can be entirely
;; ignored within an address.
(defun cfws (offset)
  (funcall (p:alt (*> +many-comments+ +opt-fws+)
                  #'fws)
           offset))

(defparameter +opt-cfws+ (p:opt #'cfws))

(defparameter +maybe-many-comments+
  (p:many (*> +opt-fws+ #'ccontent)))

(defparameter +comment+
  (p:between +paren-open+
             (*> +maybe-many-comments+
                 +opt-fws+)
             +paren-close+))

(fn comment (maybe (member nil)))
(defun comment (offset)
  "Yields NIL if successful."
  (funcall +comment+ offset))

#+nil
(p:parse #'comment "(hello(there))")

(defparameter +ccontent+
  (p:sliding-take1 (lambda (a b)
                     (cond ((ctext? a) (values :one a))
                           ((quoted-pair? a b) (values :two b))))))

(fn ccontent (maybe (or string (member nil))))
(defun ccontent (offset)
  (funcall (p:alt +ccontent+ #'comment) offset))

#+nil
(p:parse #'ccontent "hello)")

;; --- Atoms --- ;;

(defparameter +period-sep-atext+
  (p:consume-sep1 +period+ +consume-atext+))

(defparameter +recognize-atoms+
  (p:recognize +period-sep-atext+))

(fn dot-atom-text (maybe string))
(defun dot-atom-text (offset)
  "Parser: Simple dot-separated ascii atoms."
  (funcall +recognize-atoms+ offset))

#+nil
(p:parse #'dot-atom-text "foo.bar.baz")

(fn dot-atom (maybe string))
(defun dot-atom (offset)
  (funcall (p:between +opt-cfws+
                      #'dot-atom-text
                      +opt-cfws+)
           offset))

#+nil
(p:parse #'dot-atom "   (hi)hello(there)    ")

;; --- Content Parsers --- ;;

(fn addr-spec (maybe address))
(defun addr-spec (offset)
  (funcall (p:ap (lambda (name domain) (make-address :name name :domain domain))
                 #'local-part
                 (*> +@+ #'domain))
           offset))

#+nil
(p:parse #'addr-spec "   alice  (comment)   @bob.com")

#+nil
(p:parse #'addr-spec "alice@bob@charles.com")

(fn local-part (maybe string))
(defun local-part (offset)
  (funcall (p:alt (<* #'dot-atom +peek-@+)
                  (<* #'quoted-string +peek-@+)
                  #'obs-local-part)
           offset))

(fn domain (maybe string))
(defun domain (offset)
  (funcall (p:alt (<* #'dot-atom +peek-eof+)
                  #'domain-literal
                  #'obs-domain)
           offset))

;; Whitespace: https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.2

(defparameter +sliding-quoted-pairs+
  (p:sliding-take1 (lambda (a b)
                     (cond ((qtext? a) (values :one a))
                           ((quoted-pair? a b) (values :two b))))))

(defparameter +many-quoted-pairs+
  (p:many (*> +opt-fws+ +sliding-quoted-pairs+)))

(fn quoted-string (maybe p::char-string))
(defun quoted-string (offset)
  "No whitespace around or within the quotes is considered actual content."
  (funcall (p:ap (lambda (list) (apply #'concatenate 'string list))
                 (*> +opt-cfws+
                     +quote+
                     ;; FIXME: 2025-09-10 This `many' is wasteful and forces a
                     ;; reallocation into a single string above. I'm not sure
                     ;; how to get around it though, given that `fws' has a
                     ;; specific structure that is not just a matter of
                     ;; `consuming' over whitespace.
                     (<* +many-quoted-pairs+
                         +opt-fws+
                         +quote+
                         +opt-cfws+)))
           offset))

#+nil
(p:parse #'quoted-string "\"hello \\\" there\"")

(fn domain-literal (maybe simple-string))
(defun domain-literal (offset)
  (funcall
   (p:between +opt-cfws+
              (p:between +bracket-open+
                         (p:ap (lambda (list) (format nil "[~{~a~}]" list))
                               (p:many (*> +opt-fws+ #'many-dtext1)))
                         (*> +opt-fws+ +bracket-close+))
              +opt-cfws+)
   offset))

#+nil
(p:parse #'domain-literal "[hello there]")

(fn word (maybe string))
(defun word (offset)
  (funcall (p:alt #'atom #'quoted-string) offset))

(defparameter +atom+
  (p:between +opt-cfws+
             (p:take-while1 #'atext?)
             +opt-cfws+))

(fn atom (maybe string))
(defun atom (offset)
  (funcall +atom+ offset))

#+nil
(p:parse #'atom " hello ")

(defparameter +obs-local-part+
  (p:sep1 +period+ #'word))

(fn obs-local-part (maybe simple-string))
(defun obs-local-part (offset)
  (funcall (p:ap (lambda (list) (format nil "~{~a~^.~}" list))
                 +obs-local-part+)
           offset))

#+nil
(p:parse #'obs-local-part "hello . there . hi")

(defparameter +obs-domain+
  (p:sep1 +period+ #'atom))

(fn obs-domain (maybe simple-string))
(defun obs-domain (offset)
  (funcall (p:ap (lambda (list) (format nil "~{~a~^.~}" list))
                 +obs-domain+)
           offset))

#+nil
(p:parse #'obs-domain "yes . hello . there")

(fn msg-id (maybe address))
(defun msg-id (offset)
  (funcall (p:ap (lambda (name domain) (make-address :name name :domain domain))
                 #'id-left
                 (*> +@+ #'id-right))
           offset))

#+nil
(p:parse #'msg-id "colin@fosskers.ca")

(fn id-left (maybe string))
(defun id-left (offset)
  (funcall (p:alt #'dot-atom-text #'local-part) offset))

(fn id-right (maybe string))
(defun id-right (offset)
  (funcall (p:alt #'dot-atom-text #'no-fold-literal #'domain) offset))

(fn no-fold-literal (maybe string))
(defun no-fold-literal (offset)
  (funcall (p:recognize (*> +bracket-open+ #'many-dtext +bracket-close+)) offset))

(defparameter +many-dtext+
  (p:sliding-take (lambda (a b)
                    (cond ((dtext? a) (values :one a))
                          ((quoted-pair? a b) (values :two b))))))

(fn many-dtext (always string))
(defun many-dtext (offset)
  "Parser: Potentially escaped characters."
  (funcall +many-dtext+ offset))

#+nil
(defun many-dtext (offset)
  "Parser: Potentially escaped characters."
  (funcall (p:sliding-take (lambda (a b)
                             (cond ((dtext? a) (values :one a))
                                   ((quoted-pair? a b) (values :two b)))))
           offset))

#+nil
(p:parse #'many-dtext "Hello\\ there")
#+nil
(p:parse #'many-dtext "Hello there")

(fn many-dtext1 (maybe string))
(defun many-dtext1 (offset)
  "Parser: Potentially escaped characters."
  (multiple-value-bind (res next) (many-dtext offset)
    (cond ((p:failure? res) (p:fail offset))
          ((p:empty? res) (p:fail offset))
          (t (values res next)))))

#+nil
(p:parse #'many-dtext1 "")

#+nil
(parse "email@[1]")
